<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://leoeditor.com/leo_toc.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="dave.20131104221200.3213"><vh>Startup</vh>
<v t="dave.20131104221200.3214"><vh>@chapters</vh></v>
<v t="dave.20131104221200.3215"><vh>Local buttons</vh>
<v t="dave.20131104221200.3216"><vh>@button check-menus-cmds</vh></v>
<v t="dave.20131104221200.3217"><vh>@button check-settings</vh>
<v t="dave.20131104221200.3218"><vh>ctor</vh></v>
<v t="dave.20131104221200.3219"><vh>check &amp; helper</vh>
<v t="dave.20131104221200.3220"><vh>print_missing</vh></v>
</v>
<v t="dave.20131104221200.3221"><vh>error</vh></v>
<v t="dave.20131104221200.3222"><vh>get_commanders</vh></v>
<v t="dave.20131104221200.3223"><vh>get_configs &amp; helpers</vh>
<v t="dave.20131104221200.3224"><vh>get_configs_from_outline &amp; helper</vh>
<v t="dave.20131104221200.3225"><vh>scan_for_configs</vh></v>
</v>
</v>
<v t="dave.20131104221200.3226"><vh>get_settings &amp; helper</vh>
<v t="dave.20131104221200.3227"><vh>is_setting</vh></v>
<v t="dave.20131104221200.3228"><vh>parse_setting</vh></v>
</v>
<v t="dave.20131104221200.3229"><vh>munge</vh></v>
<v t="dave.20131104221200.3230"><vh>run</vh></v>
</v>
<v t="dave.20131104221200.3231"><vh>@button check-bindings</vh>
<v t="dave.20131104221200.3232"><vh>defineSetNames</vh></v>
<v t="dave.20131104221200.3233"><vh>doSet</vh></v>
<v t="dave.20131104221200.3234"><vh>doShortcuts</vh></v>
<v t="dave.20131104221200.3235"><vh>checkSets</vh></v>
<v t="dave.20131104221200.3236"><vh>main</vh></v>
</v>
<v t="dave.20131104221200.3237"><vh>Disabled/old</vh>
<v t="dave.20131104221200.3238"><vh>@@button check-bindings</vh>
<v t="dave.20131104221200.3239"><vh>defineSetNames</vh></v>
<v t="dave.20131104221200.3240"><vh>doSet</vh></v>
<v t="dave.20131104221200.3241"><vh>doShortcuts</vh></v>
<v t="dave.20131104221200.3242"><vh>checkSets</vh></v>
<v t="dave.20131104221200.3243"><vh>main</vh></v>
</v>
<v t="dave.20131104221200.3244"><vh>@@button check-core-settings (OlD)</vh>
<v t="dave.20131104221200.3245"><vh>ctor</vh></v>
<v t="dave.20131104221200.3246"><vh>get_settings</vh></v>
<v t="dave.20131104221200.3247"><vh>get_settings_nodes</vh></v>
<v t="dave.20131104221200.3248"><vh>init</vh></v>
<v t="dave.20131104221200.3249"><vh>run</vh></v>
</v>
</v>
</v>
<v t="dave.20131104221200.3250"><vh>Local commands</vh>
<v t="dave.20131104221200.3251"><vh>@command print-all-plugins</vh></v>
</v>
</v>
<v t="dave.20131104211120.8770"><vh>colors</vh>
<v t="dave.20131104221306.6376"><vh>@data qt-gui-plugin-style-sheet</vh></v>
</v>
<v t="dave.20131103203308.3163" a="E"><vh>@settings</vh>
<v t="dave.20131104222052.3612" a="E"><vh>keyboard commands</vh>
<v t="dave.20131104222052.3614"><vh>About shortcut specifiers</vh></v>
<v t="dave.20131104222052.3617" a="E"><vh>@keys daves</vh>
<v t="dave.20131112150352.3585"><vh>@button make-skull</vh></v>
<v t="dave.20131109134816.5205"><vh>@button append-text</vh></v>
<v t="dave.20131104222052.3624" a="E"><vh>@shortcuts skulls</vh>
<v t="dave.20131104222052.3636"><vh>@mode text</vh>
<v t="dave.20131104222052.3913" a="E"><vh>text</vh>
<v t="dave.20131104222052.3915" a="E"><vh>SHIFT - extend selection</vh>
<v t="dave.20131104222052.3996"><vh>@mode text-up-extend-selection</vh></v>
<v t="dave.20131104222052.3997"><vh>@mode text-back-extend-selection</vh></v>
<v t="dave.20131104222052.3998"><vh>@mode text-down-extend-selection</vh></v>
<v t="dave.20131104222052.3999"><vh>@mode text-forward-extend-selection</vh></v>
<v t="dave.20131104222052.4000"><vh>@mode text-beg-line-extend-selection</vh></v>
<v t="dave.20131104222052.4001"><vh>@mode text-end-line-extend-selection</vh></v>
</v>
<v t="dave.20131104222052.3816"><vh>@mode text-up</vh></v>
<v t="dave.20131104222052.3828"><vh>@mode text-back</vh></v>
<v t="dave.20131104222052.3830"><vh>@mode text-down</vh></v>
<v t="dave.20131104222052.3832"><vh>@mode text-forward</vh></v>
<v t="dave.20131104222052.3834"><vh>@mode text-beg-line</vh></v>
<v t="dave.20131104222052.3836"><vh>@mode text-end-line</vh></v>
</v>
<v t="dave.20131104222052.3914" a="E"><vh>block</vh>
<v t="dave.20131104222052.3916" a="E"><vh>SHIFT - extend selection</vh>
<v t="dave.20131104222052.4008"><vh>@mode text-para-prev-extend-selection</vh></v>
<v t="dave.20131104222052.4009"><vh>@mode text-sent-prev-extend-selection</vh></v>
<v t="dave.20131104222052.4010"><vh>@mode text-para-next-extend-selection</vh></v>
<v t="dave.20131104222052.4011"><vh>@mode text-sent-next-extend-selection</vh></v>
<v t="dave.20131104222052.4012"><vh>@mode text-doc-top-extend-selection</vh></v>
<v t="dave.20131104222052.4013"><vh>@mode text-doc-end-extend-selection</vh></v>
</v>
<v t="dave.20131104222052.3851"><vh>@mode text-para-prev</vh></v>
<v t="dave.20131104222052.3853"><vh>@mode text-sent-prev</vh></v>
<v t="dave.20131104222052.3865"><vh>@mode text-para-next</vh></v>
<v t="dave.20131104222052.3867"><vh>@mode text-sent-next</vh></v>
<v t="dave.20131104222052.3869"><vh>@mode text-doc-top</vh></v>
<v t="dave.20131104222052.3871"><vh>@mode text-doc-end</vh></v>
</v>
</v>
<v t="dave.20131104222052.3874"><vh>@mode window</vh>
<v t="dave.20131104222052.3921" a="E"><vh>focus</vh>
<v t="dave.20131104222052.3875"><vh>@mode window-tree</vh></v>
<v t="dave.20131104222052.3876"><vh>@mode window-editor</vh></v>
<v t="dave.20131104222052.3877"><vh>@mode window-cycle-editor</vh></v>
<v t="dave.20131104222052.3878"><vh>@mode window-cycle-log</vh></v>
<v t="dave.20131104222052.3879"><vh>@mode window-prev-tab</vh></v>
<v t="dave.20131104222052.3880"><vh>@mode window-next-tab</vh></v>
</v>
<v t="dave.20131104222052.3922" a="E"><vh>sizing</vh>
<v t="dave.20131104222052.3881"><vh>@mode window-expand-body</vh></v>
<v t="dave.20131104222052.3884"><vh>@mode window-expand-log</vh></v>
<v t="dave.20131104222052.3883"><vh>@mode window-contract-body</vh></v>
<v t="dave.20131104222052.3882"><vh>@mode window-contract-log</vh></v>
<v t="dave.20131104222052.3885"><vh>@mode window-add-editor</vh></v>
<v t="dave.20131104222052.3886"><vh>@mode window-delete-editor</vh></v>
</v>
</v>
<v t="dave.20131104222052.3900"><vh>@mode node</vh>
<v t="dave.20131104222052.3917"><vh>leaf</vh>
<v t="dave.20131104222052.3919"><vh>SHIFT - move</vh></v>
<v t="dave.20131104222052.3901"><vh>@mode node-prev</vh></v>
<v t="dave.20131104222052.3902"><vh>@mode node-left</vh></v>
<v t="dave.20131104222052.3903"><vh>@mode node-next</vh></v>
<v t="dave.20131104222052.3904"><vh>@mode node-right</vh></v>
<v t="dave.20131104222052.3905"><vh>@mode node-first-sib</vh></v>
<v t="dave.20131104222052.3906"><vh>@mode node-last-sib</vh></v>
</v>
<v t="dave.20131104222052.3918"><vh>branch</vh>
<v t="dave.20131104222052.3920"><vh>SHIFT - rename/copypasta</vh></v>
<v t="dave.20131104222052.3907"><vh>@mode node-goto-parent</vh></v>
<v t="dave.20131104222052.3908"><vh>@mode node-history-prev</vh></v>
<v t="dave.20131104222052.3909"><vh>@mode node-toggle-sub</vh></v>
<v t="dave.20131104222052.3910"><vh>@mode node-history-next</vh></v>
<v t="dave.20131104222052.3911"><vh>@mode node-first</vh></v>
<v t="dave.20131104222052.3912"><vh>@mode node-last</vh></v>
</v>
</v>
<v t="dave.20131104222052.3619" a="E"><vh>@mode find</vh>
<v t="dave.20131104222052.3925" a="E"><vh>search/replace</vh>
<v t="dave.20131104222052.3940"><vh>SHIFT - reverse/alt</vh>
<v t="dave.20131104222052.3984"><vh>@mode find-search-back</vh></v>
<v t="dave.20131104222052.3936"><vh>@mode find-find-next-find</vh></v>
<v t="dave.20131104222052.3986"><vh>@mode find-replace-all</vh></v>
<v t="dave.20131104222052.3987"><vh>@mode find-prev-find</vh></v>
<v t="dave.20131104222052.3988"><vh>@mode find-spell-find</vh></v>
<v t="dave.20131104222052.3989"><vh>@mode find-find-at-cursor-back</vh></v>
</v>
<v t="dave.20131104222052.3927"><vh>@mode find-search</vh></v>
<v t="dave.20131104222052.3932"><vh>@mode find-replace-and-next</vh></v>
<v t="dave.20131104222052.3929"><vh>@mode find-replace</vh></v>
<v t="dave.20131104222052.3936"></v>
<v t="dave.20131104222052.3944"><vh>@mode find-spell-find</vh></v>
<v t="dave.20131104222052.3937"><vh>@mode find-find-at-cursor-forw</vh></v>
</v>
<v t="dave.20131104222052.3926" a="E"><vh>navigation</vh>
<v t="dave.20131104222052.3941"><vh>SHIFT - reverse</vh>
<v t="dave.20131104222052.3950"><vh>@mode find-next-mark-shift</vh></v>
<v t="dave.20131104222052.3943"><vh>@mode find-find-quick-selected</vh></v>
<v t="dave.20131104222052.3952"><vh>@mode find-iter-prev</vh></v>
<v t="dave.20131104222052.3953"><vh>@mode find-char-backward</vh></v>
</v>
<v t="dave.20131104222052.3933"><vh>@mode find-next-mark</vh></v>
<v t="dave.20131104222052.3939"><vh>@mode find-find-quick</vh></v>
<v t="dave.20131104222052.3930"><vh>@mode find-iter-next</vh></v>
<v t="dave.20131104222052.3938"><vh>@mode find-char-forward</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="dave.20131104222052.3593"><vh>Commands for mouseless Leo</vh></v>
<v t="dave.20131104222052.3611"><vh>bucket</vh></v>
</vnodes>
<tnodes>
<t tx="dave.20131103203308.3163"></t>
<t tx="dave.20131104211120.8770"></t>
<t tx="dave.20131104221200.3213"></t>
<t tx="dave.20131104221200.3214"></t>
<t tx="dave.20131104221200.3215"></t>
<t tx="dave.20131104221200.3216">'''Check all commands mentioned in the @menus tree
   to ensure that they exist.'''

def checkMenu (p):
    for p2 in p.subtree_iter():
        if p2.h.startswith('@item'):
            checkItem(p.h,p2)

def checkItem (menuName,p):
    h = p.h[len('@item'):].replace('&amp;','').replace('*','').strip()
    if h != '-' and h not in c.commandsDict:
        print ('command not found: %s: %s' % (menuName,p.h))

menus = g.findNodeAnywhere(c,'@menus')
assert menus, 'no @menus tree'
for p in menus.subtree_iter():
    if p.h.startswith('@menu'):
        checkMenu(p.copy())

print ('done')
</t>
<t tx="dave.20131104221200.3217">class Controller:
    @others
    
Controller(c).run()</t>
<t tx="dave.20131104221200.3218">def __init__ (self,c):
    self.c = c
    
    self.errors = 0
    
    # Commanders.
    self.core = None # Commander for leoPy.leo.
    self.plugins = None # Commander for leoPlugins.leo.
    self.settings = None # Commander for leoSettings.leo.
</t>
<t tx="dave.20131104221200.3219">def check (self,configs_d,settings_d):
    
    table = ('Bool','Color','Int','Float',# 'Font',
        'Ratio','Path','String',
    )
    format = '%40s %s'
    
    if 1: # Less important: print missing settings.
        for kind in table:
            config_key = 'get%s' % kind
            settings_key = '@%s' % kind.lower()
            
            config_list = configs_d.get(config_key,[])
            settings_list = settings_d.get(settings_key,[])
            
            munged_config_list =   [self.munge(s) for s in config_list]
            munged_settings_list = [self.munge(s) for s in settings_list]
            
            print('\nmissing %s settings...' % settings_key)
            missing = set()
            for s in munged_config_list:
                # Ignore plugins settings.
                if s not in munged_settings_list:
                    missing.add(s)

            if missing:
                print(format % ('Canonical','Actual'))
                print(format % ('=' * len('Canonical'),'=' * len('Actual')))
                for s in sorted(list(missing)):
                    self.print_missing(format,s,
                        config_list,settings_list,
                        munged_config_list,munged_settings_list)
                    
                        
    # More important: print missing calls to c.config.getX
    if 1:
        for kind in table:
            config_key = 'get%s' % kind
            settings_key = '@%s' % kind.lower()
            
            config_list = configs_d.get(config_key,[])
            settings_list = settings_d.get(settings_key,[])
            
            munged_config_list =   [self.munge(s) for s in config_list]
            munged_settings_list = [self.munge(s) for s in settings_list]

            print('\nmissing config.%s calls...' % config_key)
            missing = set()
            for s in munged_settings_list:
                if s not in munged_config_list:
                    missing.add(s)

            if missing:
                print(format % ('Canonical','Actual'))
                print(format % ('=' * len('Canonical'),'=' * len('Actual')))
                for s in sorted(list(missing)):
                    self.print_missing(format,s,
                        settings_list,config_list,
                        munged_settings_list,munged_config_list)</t>
<t tx="dave.20131104221200.3220">def print_missing(self,format,munged_s,in_list,out_list,munged_in_list,munged_out_list):
    
    '''Print the canonical name, followed by the list of names that match.'''
    
    assert munged_s in munged_in_list,munged_s
    assert munged_s not in munged_out_list,munged_s
    
    if 0: # These should not be necessary.  Something is wrong.
        
        # Ignore plugins settings and global switches.
        for prefix in ('color','datenodes','http','opml','rst3','todo','trace','vim','zodb'):
            if munged_s.startswith(prefix):
                return
                
    # Ignore color settings.  They are handled differently...
    for suffix in ('color',):
        if munged_s.endswith(suffix):
            return
    
    match_list = [s for s in in_list if self.munge(s) == munged_s]
    
    print(format % (munged_s,match_list))</t>
<t tx="dave.20131104221200.3221">def error (self,s):
    
    print(s)
    self.errors += 1
</t>
<t tx="dave.20131104221200.3222">def get_commanders (self):
    
    '''Open files as needed and set the commander ivars.'''
    
    def open_commander(fn):
        c = g.openWithFileName(fn,old_c=self.c,gui=g.app.nullGui)
        if c: return c
        else:
            self.error('not found: %s' % fn)
            
    self.core = open_commander(
        g.os_path_join(g.app.loadDir,'..','core','leoPy.leo'))
            
    self.plugins = open_commander(
        g.os_path_join(g.app.loadDir,'..','plugins','leoPlugins.leo'))
        
    self.settings = open_commander(
        g.os_path_join(g.app.loadDir,'..','config','leoSettings.leo'))
        
    # g.trace('\n%s\n%s\n%s' % (self.core,self.plugins,self.settings))
</t>
<t tx="dave.20131104221200.3223">def get_configs(self):
    
    '''Return a dict containing a representation
    of all calls to x.config.getX.
    '''
    
    d = {}
    
    for c in (self.core,self.plugins):
        print('scanning: %s' % c.shortFileName())
        self.get_configs_from_outline(c,d)
    
    return d</t>
<t tx="dave.20131104221200.3224">def get_configs_from_outline (self,c,d):
    
    '''Scan the outline for all calls to x.config.getX
    and add items to d.
    '''
    
    trace = True
    
    for p in c.all_positions():
        self.scan_for_configs(p,d)
        
    if trace:
        for key in sorted(list(d.keys())):
            print(key)
            aList = d.get(key)
            for name in sorted(aList):
                print('  ' + name)
    
    return d</t>
<t tx="dave.20131104221200.3225">def scan_for_configs (self,p,d):
    
    '''Scan the body text of p, finding all calls to getX.'''

    kinds = ('getBool','getColor','getInt','getFloat',
        # '@font', # special case.
        'getRatio','getPath','getString',
    )
    i,s = 0,p.b
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if (
            ch == '@' and
            (g.match(s,i,'@ ') or g.match(s,i,'@\n')) and 
            (i == 0 or s[i-1] == '\n')
        ):
            i = s.find('\n@c',i)
            if i == -1: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch in ('"',"'"):
            i = g.skip_string(s,i,verbose=False)
        elif ch == '_' or ch.isalpha():
            j = g.skip_id(s,i)
            kind = s[i:j]
            if kind in kinds:
                i = g.skip_ws(s,j)
                if g.match(s,i,'('):
                    i = g.skip_ws(s,i+1)
                    if g.match(s,i,'"') or g.match(s,i,"'"):
                        j = g.skip_string(s,i)
                        name = s[i+1:j-1]
                        aList = d.get(kind,[])
                        if name not in aList:
                            aList.append(name)
                        d [kind] = aList
            i = j
        else:
            i += 1
        assert progress &lt; i
    
    return d</t>
<t tx="dave.20131104221200.3226">def get_settings (self):
    
    '''Return a dict containing a representation
    of all settings in leoSettings.leo.
    '''
    
    trace = False
    c,d = self.settings,{}
    
    print('scanning: %s' % c.shortFileName())

    settings_node = g.findNodeAnywhere(c,'@settings')
    if not settings_node:
        return self.error('no @settings node')
        
    for p in settings_node.subtree():
        if self.is_setting(p):
            kind,name = self.parse_setting(p)
            if name:
                # name = self.munge(name)
                aList = d.get(kind,[])
                if name not in aList:
                    aList.append(name)
                d [kind] = aList
            else:
                self.error('no name for %s' % (kind))
                
    if trace:
        keys = list(d.keys())
        for key in sorted(keys):
            print(key)
            aList = d.get(key)
            for name in sorted(aList):
                print('  ' + name)

    return d</t>
<t tx="dave.20131104221200.3227">def is_setting (self,p):
    
    # For now, these are enough
    table = (
        '@bool','@color','@int','@float',
        # '@font', # special case.
        '@ratio','@path','@string',
    )
    
    for s in table:
        if g.match_word(p.h,0,s):
            return True
    return False</t>
<t tx="dave.20131104221200.3228">def parse_setting (self,p):
    
    s = p.h
    assert s[0] == '@'
    i = g.skip_id(s,1)
    kind = s[:i]
    assert kind
    i = g.skip_ws(s,i)
    j = g.skip_id(s,i,chars='-')
    name = s[i:j]
    return kind,name</t>
<t tx="dave.20131104221200.3229">def munge (self,s):
    
    '''Return the canonicalized name for settings and arguments to c.config.getX.'''
    
    return s.replace('-','').replace('_','').lower()</t>
<t tx="dave.20131104221200.3230">def run(self):
    
    import os ; os.system('cls')
    
    self.get_commanders()
    configs = self.get_configs()
    settings = self.get_settings()
    
    if self.errors == 0:
        self.check(configs,settings)
        
    g.trace('done')</t>
<t tx="dave.20131104221200.3231">'''This script reports commands that exist in some but not all key- binding
sets. setNames is a list of the roots of all such sets.'''

import leo.core.leoConfig as leoConfig
import leo.core.leoTest as leoTest

# u = leoTest.testUtils(c)
parser = leoConfig.SettingsTreeParser(c)

# Add these as required to handle commands defined by plugins.
optionalCommandPrefixes = ['group-operations']
optionalCommandNames = [
    # These are the command names as defined by plugins.
    # LeoSlideShows.leo defines buttons whose commands do not end in '-command'.
    'next-slide-command','next-slide-show-command',
    'prev-slide-command','prev-slide-show-command',
    # The ipython plugin.
    'start-ipython','get-ipython-results','push-to-ipython',
]

setNames = []
setsDict = {} # keys are set names, values are dicts of command names.
shortcutsDict = {}

@others

main()
</t>
<t tx="dave.20131104221200.3232">def defineSetNames():

    global setNames

    if 1:
        setNames = []
        for p in c.allNodes_iter():
            h = p.headString()
            if h.startswith('@keys'):
                h = h[5:].strip()
                if h not in setNames:
                    setNames.append(h)
        g.es('Found these sets...')
        for setName in setNames:
            g.es_print('  %s' % str(setName))
    else:
        setNames = [
            'Default Emacs shortcuts',
            'Legacy Leo bindings',
            'Legacy Leo shortcuts with important Emacs bindings',
            'No bindings',
            'EKR bindings: a mix',
            'EKR bindings: Mode-oriented',
        ]

    setNames.sort()
</t>
<t tx="dave.20131104221200.3233">def doSet(p,name):

    global shortcutsDict

    shortcutsDict = {}

    for p in p.subtree_iter():
        if p.headString().startswith('@shortcuts'):
            doShortcuts(p,name)
</t>
<t tx="dave.20131104221200.3234">def doShortcuts(p,setName):

    global parser,setsDict,shortcutsDict

    d = setsDict.get(setName,{})
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not line.startswith('#'):
            commandName,si = parser.parseShortcutLine('test',line)
            if not si:
                g.es_print('In %s:\nmissing "=" in shortcut line:%s' % (
                    p.headString(),repr(line)),color='red')
            else:
                # Having multiple shortcuts for a command if fine,
                # But having multiple commands for a shortcut is not.
                shortcut = si.stroke
                pane = si.pane
                if shortcut not in (None,'None','none'):
                    aList = shortcutsDict.get(shortcut,[])
                    if aList:
                        for commandName2,pane2 in aList:
                            if pane == pane2:
                                g.es_print('duplicate shortcut %s in set %s: previous command: %s' % (
                                    shortcut,setName,commandName2),color='red')
                        else:
                            aList.append((commandName,pane),)
                    else:
                        shortcutsDict [shortcut] = [(commandName,pane),]

                data = d.get(commandName)
                if data:
                    shortcut2,pane2 = data
                    if shortcut == shortcut2 and pane == pane2:
                        g.es_print('duplicate %s in set %s' % (
                            commandName,setName),color='red')
                else:
                    data = shortcut,pane
                    d[commandName] = data

    setsDict[setName] = d
</t>
<t tx="dave.20131104221200.3235">def checkSets():

    global setNames, optionalCommandPrefixes, optionalCommandNames

    # Compute the union of all the command names.
    allNames = {}
    for setName in setNames:
        d = setsDict.get(setName)
        if d:
            for key in d.keys():
                allNames[key] = key
        else:
            g.es_print('No setsDict for %s' % (repr(setName)),color='red')

    k = c.keyHandler
    keys = list(allNames.keys())
    keys.sort()

    # Warn about missing names.
    for setName in ('No bindings',): # setNames:
        d = setsDict.get(setName)
        if not d:
            g.es_print("'@keys No bindings' not found",color='red')
        for key in keys:
            if key not in ('none','None',None) and key not in d.keys():
                # Don't warn about missing 'enter-xxx-mode' commands.
                if (
                    not (key.startswith('enter-') and key.endswith('-mode')) and
                    not (key.startswith('press-') and key.endswith('-button'))
                ):
                    g.es_print('%s is missing %-35s = None' % (setName,repr(key)))

    # Warn about undefined commands.
    for key in keys:
        if not c.commandsDict.get(key):
            ok = False
            # full-command and quick command are weird special cases.
            if key not in ('None',None,'full-command','quick-command'):
                # Don't warn about missing 'enter-xxx-mode' commands.
                if key.startswith('enter-') and key.endswith('-mode'):
                    ok = True
                elif key.startswith('press-') and key.endswith('-button'):
                    ok = True
                for prefix in optionalCommandPrefixes:
                    if key.startswith(prefix):
                        ok = True
                for optionalCommand in optionalCommandNames:
                    if key == optionalCommand:
                        ok = True
                if not ok:
                    g.es_print('Undefined command name: %s' % (key))
</t>
<t tx="dave.20131104221200.3236">def main ():

    global setNames
    defineSetNames()

    g.es_print('-' * 40)
    seen = {}
    for p in c.allNodes_iter():
        h = p.headString()
        if h.startswith('@keys'):
            h = h[5:].strip()
            if not seen.get(h):
                seen[h] = True
                doSet(p,h)
    checkSets()
    g.es('Check Bindings done')
</t>
<t tx="dave.20131104221200.3237"></t>
<t tx="dave.20131104221200.3238">'''This script reports commands that exist in some but not all key- binding
sets. setNames is a list of the roots of all such sets.'''

import leoConfig
import leoTest

parser = leoConfig.SettingsTreeParser(c)

# Add these as required to handle commands defined by plugins.
optionalCommandPrefixes = ['group-operations']
optionalCommandNames = [
    # These are the command names as defined by plugins.
    # LeoSlideShows.leo defines buttons whose commands do not end in '-command'.
    'next-slide-command','next-slide-show-command',
    'prev-slide-command','prev-slide-show-command',
    # The ipython plugin.
    'start-ipython','get-ipython-results','push-to-ipython',
]

setNames = []
setsDict = {} # keys are set names, values are dicts of command names.
shortcutsDict = {}

@others

main()
</t>
<t tx="dave.20131104221200.3239">def defineSetNames():

    global setNames

    if 1:
        setNames = []
        for p in c.allNodes_iter():
            h = p.headString()
            if h.startswith('@keys'):
                h = h[5:].strip()
                if h not in setNames:
                    setNames.append(h)
        g.es('Found these sets...')
        for setName in setNames:
            g.es_print('  %s' % str(setName))
    else:
        setNames = [
            'Default Emacs shortcuts',
            'Legacy Leo bindings',
            'Legacy Leo shortcuts with important Emacs bindings',
            'No bindings',
            'EKR bindings: a mix',
            'EKR bindings: Mode-oriented',
        ]

    setNames.sort()
</t>
<t tx="dave.20131104221200.3240">def doSet(p,name):

    global shortcutsDict

    shortcutsDict = {}

    for p in p.subtree_iter():
        if p.headString().startswith('@shortcuts'):
            doShortcuts(p,name)
</t>
<t tx="dave.20131104221200.3241">def doShortcuts(p,setName):

    global parser,setsDict,shortcutsDict

    d = setsDict.get(setName,{})
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not line.startswith('#'):
            commandName,bunch = parser.parseShortcutLine('test',line)
            if not bunch:
                g.es_print('In %s:\nmissing "=" in shortcut line:%s' % (
                    p.headString(),repr(line)),color='red')
            else:
                # Having multiple shortcuts for a command if fine,
                # But having multiple commands for a shortcut is not.
                shortcut = bunch and bunch.val
                pane = bunch and bunch.pane
                if shortcut not in (None,'None','none'):
                    aList = shortcutsDict.get(shortcut,[])
                    if aList:
                        for commandName2,pane2 in aList:
                            if pane == pane2:
                                g.es_print('duplicate shortcut %s in set %s: previous command: %s' % (
                                    shortcut,setName,commandName2),color='red')
                        else:
                            aList.append((commandName,pane),)
                    else:
                        shortcutsDict [shortcut] = [(commandName,pane),]

                data = d.get(commandName)
                if data:
                    shortcut2,pane2 = data
                    if shortcut == shortcut2 and pane == pane2:
                        g.es_print('duplicate %s in set %s' % (
                            commandName,setName),color='red')
                else:
                    data = shortcut,pane
                    d[commandName] = data

    setsDict[setName] = d
</t>
<t tx="dave.20131104221200.3242">def checkSets():

    global setNames, optionalCommandPrefixes, optionalCommandNames

    # Compute the union of all the command names.
    allNames = {}
    for setName in setNames:
        d = setsDict.get(setName)
        if d:
            for key in d.keys():
                allNames[key] = key
        else:
            g.es_print('No setsDict for %s' % (repr(setName)),color='red')

    k = c.keyHandler
    keys = allNames.keys()
    keys.sort()

    # Warn about missing names.
    for setName in ('No bindings',): # setNames:
        d = setsDict.get(setName)
        if not d:
            g.es_print("'@keys No bindings' not found",color='red')
        for key in keys:
            if key not in ('none','None',None) and key not in d.keys():
                # Don't warn about missing 'enter-xxx-mode' commands.
                if (
                    not (key.startswith('enter-') and key.endswith('-mode')) and
                    not (key.startswith('press-') and key.endswith('-button'))
                ):
                    g.es_print('%s is missing %-35s = None' % (setName,repr(key)))

    # Warn about undefined commands.
    for key in keys:
        if not c.commandsDict.get(key):
            ok = False
            # full-command and quick command are weird special cases.
            if key not in ('None',None,'full-command','quick-command'):
                # Don't warn about missing 'enter-xxx-mode' commands.
                if key.startswith('enter-') and key.endswith('-mode'):
                    ok = True
                elif key.startswith('press-') and key.endswith('-button'):
                    ok = True
                for prefix in optionalCommandPrefixes:
                    if key.startswith(prefix):
                        ok = True
                for optionalCommand in optionalCommandNames:
                    if key == optionalCommand:
                        ok = True
                if not ok:
                    g.es_print('Undefined command name: %s' % (key))
</t>
<t tx="dave.20131104221200.3243">def main ():

    global setNames
    defineSetNames()

    g.es_print('-' * 40)
    seen = {}
    for p in c.allNodes_iter():
        h = p.headString()
        if h.startswith('@keys'):
            h = h[5:].strip()
            if not seen.get(h):
                seen[h] = True
                doSet(p,h)
    checkSets()
    g.es('Check Bindings done')
</t>
<t tx="dave.20131104221200.3244">'''Check that all settings in leoPy.leo are defined here, and vice versa.'''

import os

class CheckSettings:
    @others

CheckSettings(c).run()
</t>
<t tx="dave.20131104221200.3245">def __init__ (self,c):

    self.c = c
    self.core_c = None
    self.settingsNames =  (
        # 'getAbbrevDict','getCommonCommands',
        # 'getDirectory',
        # 'getEnabledPlugins','getLanguage',
        # 'getMenusList','getOpenWith',
        # 'getRecentFiles','getShortcut',
        'getBool','getColor','getData',
        'getFloat','getFontFromParams',
        'getInt','getRatio','getString',
    )
    self.settingsAtNames = (
        '@bool','@color','@data','@float',
        '@int','@ratio','@strings','@string',
    )

    self.init()
</t>
<t tx="dave.20131104221200.3246">def get_settings (self,aList,p):
    
    '''Append all settings names in position p to aList'''
        
    names = self.settingsNames
    for s in g.splitLines(p.b):
        for s2 in names:
            pat = 'config.%s' % (s2)
            i = s.find(pat)
            if i &gt; -1:
                i = g.skip_ws(s,i+len(pat))
                if g.match(s,i,'('):
                    i += 1
                    s3 = s[i:].strip()
                    for delim in ('"',"'"):
                        if s3.startswith(delim):
                            j = s3.find(delim,1)
                            if j &gt; -1:
                                s4 = s3[1:j]
                                if not s4.startswith('%'):
                                    aList.append(s4)
                                    break
                break
            i = s.find('config.get(')
            if i &gt; -1:
                break # Ignore this.
            i = s.find('config.get(')
            if i &gt; -1:
                aList.append('*** %s' % (s))
                break
</t>
<t tx="dave.20131104221200.3247">def get_settings_nodes (self,aList,p):
    
    '''Append all settings names in position p to aList'''

    s = p.h
    for s2 in self.settingsAtNames:
        if s.startswith(s2):
            i = g.skip_ws(s,len(s2))
            if s2 == '@strings':
                j = s.find('=')
                if j &gt; -1:
                    aList.append(s[:j].strip().replace(' ',''))
            else:
                j = g.skip_id(s,i)
                if j &gt; 0:
                    word = s[i:j]
                    # aList.append(word)
                    # aList.append(s.strip())
                    if word:
                        aList.append(s[:j].strip())
                    break
            break
        i = s.find('config.get(')
        if i &gt; -1:
            break # Ignore this.
        i = s.find('config.get(')
        if i &gt; -1:
            aList.append('*** %s' % (s))
            break
</t>
<t tx="dave.20131104221200.3248">def init (self):
    
    # leoPy.leo must be available.
    for f in g.app.windowList:
        c = f.c
        fn = c.shortFileName()
        if fn == 'leoPy.leo':
            self.core_c = c
            return
    else:
        self.core_c = None
</t>
<t tx="dave.20131104221200.3249">def run (self):
    
    verbose = False
    settings_node = g.findNodeAnywhere(self.c,'@settings')

    if not self.core_c:
        return g.error('leoPy.leo must be open')

    if not settings_node:
        return g.error('no @settings node in leoPy.leo')
    
    # Step 1: compute aList1, the list of all settings in Leo's core.
    aList1 = []
    for p in self.core_c.all_positions():
        self.get_settings(aList1,p)
        aList1 = list(set(aList1))
        aList1.sort()
        
    # Step 2: compute aList2, the list of all settings nodes in leoSettings.leo.
    aList2 = []
    for p in settings_node.subtree():
        self.get_settings_nodes(aList2,p)
        aList2 = list(set(aList2))
        aList2.sort()
        
    if verbose:
        os.system('cls')
    else:
        print('-'*10)
    
    for aList,tag in ((aList1,'leoPy.leo'),(aList2,'leoSettings.leo')):
        nl = g.choose(verbose,'\n','')
        end = g.choose(verbose,'...','')
        print('%s%s unique settings in %s%s%s' % (
            nl,len(aList),tag,end,nl))
        if verbose:
            for z in aList:
                print(z.strip())
        
    if verbose: g.es_print('done')</t>
<t tx="dave.20131104221200.3250"></t>
<t tx="dave.20131104221200.3251">import glob

path = g.os_path_finalize_join(
    g.app.loadDir,'..','plugins','*.py')
    
aList = glob.glob(path)
aList.sort()

for fn in aList:
    print(g.shortFileName(fn))</t>
<t tx="dave.20131104221306.6376"> /* Documentation of Qt stylesheets at http://doc.trolltech.com/4.2/stylesheet.html */

/* constants - *parsed from this comment*

   needed for zoom in / out
   
   @font-size-body = 12px
   
   *color names*
   @MistyRose1 = #FFE4E1
   @LightSteelBlue1 = #CAE1FF
   @LightBlue = #ADD8E6

   Buttons may be styled by name:
      QPushButton#&lt;button text&gt;-button { &lt;style&gt; }
   or by kind:
      QPushButton[button_kind="&lt;button kind&gt;"] { &lt;style&gt; }
   Button kinds are:
   'run-script' (the singleton run-script button),
   'debug-script',
   'script-button-button' (the singleton script-button button), 
   'script-button' (buttons created by the script-button button),
   'generic-button' (default), 
   'quick-move' from the quickMove plugin,
   'interact' from the interact plugin,
   'at-button' (created from @button nodes)
   Search 'button_kind' below for button styling examples.
   
   *button background colors*
   @run-script-btn-bg = @MistyRose1
   @debug-script-btn-bg = @MistyRose1
   @script-button-button-btn-bg = #ffffcc
   @script-button-btn-bg = @MistyRose1
   @generic-button-btn-bg = @LightSteelBlue1
   @quick-move-btn-bg = @LightSteelBlue1
   @interact-btn-bg = @LightBlue
   @at-button-btn-bg = @LightSteelBlue1
       
*/

/* Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords */

/*
    Important: this stylesheets is responsible for most, but *not* all, of Leos appearance.
    See also settings in "Colorizer and colors" 
*/

QScrollArea {
    background-color: white;
}

/* Components of the Find Tab */

QWidget#findTab {
    background-color: white;
}

QLabel#findHeading {
    font-family: DejaVu Sans Mono;
    font-size: 14px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel#findLabel {
    font-family: DejaVu Sans Mono;
    font-size: 14px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel#changeLabel {
    font-family: DejaVu Sans Mono;
    font-size: 14px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLineEdit#findPattern {
    font-family: DejaVu Sans Mono;
    font-size: 14px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLineEdit#findChange {
    font-family: DejaVu Sans Mono;
    font-size: 14px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* A QWidget: supports only background attributes.*/

QSplitter::handle {
    background-color: #99DDAA; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
    show-decoration-selected: 1 /* 1: select entire row */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: white;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: DejaVu Sans Mono;
    /* font-family: Courier New; */
    font-size: @font-size-body;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}

/* The text "Minibuffer" in the minibuffer aread.

Do not overide QLabel directly.  It is used for dialog text.
*/

QLabel#minibufferLabel {
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; 
    font-style: normal;
}

/* The mini-buffer

**Important**: Because Leo changes the color of the minibuffer dynamically,
stylesheets can not be used. Instead, set the desired colors using one of the
following settings, with defaults as shown::

    @color minibuffer-background-color = lightblue
    @color minibuffer-error-color = red
    @color minibuffer-foreground-color = black
    @color minibuffer-warning-color = lightgrey
*/
QLineEdit#lineEdit {
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLineEdit#status1 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
}

QLineEdit#status2 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
}

/* button_kind based button coloring */
QPushButton[button_kind="run-script"] { 
    background-color: @run-script-btn-bg; }
QPushButton[button_kind="debug-script"] { 
    background-color: @debug-script-btn-bg; }
QPushButton[button_kind="generic-button"] { 
    background-color: @generic-button-btn-bg; }
QPushButton[button_kind="quick-move"] { 
    background-color: @quick-move-btn-bg; }
QPushButton[button_kind="interact"] { 
    background-color: @interact-btn-bg; }
QPushButton[button_kind="at-button"] { 
    background-color: @at-button-btn-bg; }
QPushButton[button_kind="script-button"] { 
    background-color: @script-button-btn-bg; }
/* example of name based button coloring.  Coincidentally, the
   name and button_kind of this button are the same */
QPushButton#script-button-button { 
    background-color: @script-button-button-btn-bg; }

QPlainTextEdit#screencastcaption {
    background-color: yellow;
    font-family: DejaVu Sans Mono; /* Times New Roman; */
    font-size: 18pt;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* focused pane border highlight */
QTextEdit#log-widget, LeoQTreeWidget#treeWidget, QTextEdit#richTextEdit { 
  border-style: @focused-border-style;
  border-width: @focused-border-width; 
  border-color: @focused-border-unfocus-color; 
}
QTextEdit:focus#log-widget, LeoQTreeWidget:focus#treeWidget, QTextEdit:focus#richTextEdit { 
  border-style: @focused-border-style;
  border-width: @focused-border-width; 
  border-color: @focused-border-focus-color; 
}
</t>
<t tx="dave.20131104222052.3593">The following commands are will be useful for operating Leo without a mouse.

Clicks

click-headline -&gt; same = X
click-icon-box -&gt; same = X
double-click-headline -&gt; same = X
-&gt; -&gt; same = X
same -&gt; same = X
= -&gt; same = X
X -&gt; same = X
double-click-icon-box -&gt; same = X
-&gt; -&gt; same = X
same -&gt; same = X
= -&gt; same = X
X -&gt; same = X
Cursor -&gt; same = X
moves -&gt; same = X
and -&gt; same = X
selection -&gt; same = X
(Basic -&gt; same = X
Emacs -&gt; same = X
commands) -&gt; same = Xback-char
back-char-extend-selection
back-paragraph
back-paragraph-extend-selection
back-sentence
back-sentence-extend-selection
back-to-indentation
back-word
back-word-extend-selection
backward-delete-char
backward-kill-paragraph
backward-kill-sentence
backward-kill-word
beginning-of-buffer
beginning-of-buffer-extend-selection
beginning-of-line
beginning-of-line-extend-selection
buffer-prepend-to
delete-char
end-of-buffer
end-of-buffer-extend-selection
end-of-line
end-of-line-extend-selection
exchange-point-mark
forward-char
forward-char-extend-selection
forward-paragraph
forward-paragraph-extend-selection
forward-sentence
forward-sentence-extend-selection
forward-word
forward-word-extend-selection
insert-newline
kill-line
kill-to-end-of-line
kill-paragraph
kill-region
kill-region-save
kill-sentence
kill-word
move-past-close
move-past-close-extend-selection
newline-and-indent 
next-line
next-line-extend-selection
paste-text
previous-line
previous-line-extend-selection
rectangle-kill
register-point-to
scroll-down-half-page
scroll-down-line
scroll-down-page
scroll-up-line
scroll-up-page
yank
yank-pop  
zap-to-character

Focus

abort-edit-headline
cycle-focus
edit-headline
end-edit-headline
focus-to-body
focus-to-log
focus-to-minibuffer
focus-to-tree

Menus

activate-cmds-menu
activate-edit-menu
activate-file-menu
activate-help-menu
activate-outline-menu
activate-plugins-menu
activate-window-menu

Nodes: selecting, expanding and contracting

contract-all
contract-node
contract-or-go-left
contract-parent
equal-sized-panes
expand-all
expand-and-go-right
expand-next-level
expand-node
expand-or-go-right
expand-prev-level
go-back
go-forward
goto-char
goto-first-node
goto-first-sibling
goto-first-visible-node
goto-last-node
goto-last-sibling
goto-last-visible-node
goto-next-node
goto-next-sibling
goto-next-visible
goto-parent
goto-prev-node
goto-prev-sibling
goto-prev-visible

Panes

contract-body-pane
contract-log-pane
contract-outline-pane
contract-pane
expand-body-pane
expand-log-pane
expand-outline-pane
expand-pane
find-tab-hide
fully-expand-body-pane
fully-expand-log-pane
fully-expand-outline-pane
fully-expand-pane
hide-body-pane
hide-log-pane
hide-pane
hide-outline-pane
hide-spell-tab

Furthermore, the find commands are a good tool for using Leo without a mouse
(More commands are coming)

replace
replace-all
replace-then-find
find-next
find-all
find-prev
isearch-backward
isearch-backward-regexp
isearch-forward
isearch-forward-regexp
find-tab-open
# query-replace
# query-replace-regex
replace-string
search-again
search-backward
search-forward
search-with-present-options

Setting find options:

enter-find-options-mode
set-find-everywhere
set-find-node-only
set-find-suboutline-only
show-find-options
toggle-find-ignore-case-option
toggle-find-in-body-option
toggle-find-in-headline-option
toggle-find-mark-changes-option
toggle-find-mark-finds-option
toggle-find-regex-option
# toggle-find-reverse-option
toggle-find-word-option
toggle-find-wrap-around-option
word-search-backward
word-search-forward</t>
<t tx="dave.20131104222052.3611">can leo reload settings without a restart?</t>
<t tx="dave.20131104222052.3612">first:

cycle-editor-focus
</t>
<t tx="dave.20131104222052.3614">The following special single characters may be used in the tails of shortcuts.
They are listed along with their associated Tk binding value. Leo contains
special code to handle these characters. No other single characters may be
specified.

For example, you could specify Ctrl+! as a shortcut, and Leo will create a
binding for &lt;Control+exclam&gt;. Some of these values may be invalid on some
machines.

The full list is at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm

! exclam
" quotedbl
# numbersign
$ dollar
% percent
&amp; ampersand
' quoteright
( parenleft
) parenright
* asterisk
+ plus
, comma
- minus
. period
/ slash
: colon
; semicolon
&lt; less
= equal
&gt; greater
? question
@ at
[ bracketleft
\ backslash
] bracketright
^ asciicircum
_ underscore
` quoteleft
{ braceleft
| bar
} braceright
~ asciitilde

Leo recognizes the following mult-character names, and translates the indicated
strings in the menu items:
    
"bksp"     : "BkSp"
"dnarrow"  : "DnArrow"
"ltarrow"  : "LtArrow"
"rtarrow"  : "RtArrow"
"uparrow"  : "UpArrow"
"pageup"   : "PgUp"),
"pagedn"   : "PgDn")

For example, "Ctrl-uparrow"  will appear as "Ctrl+UpArrow" in the menu.

Leo passes all other mult-character names verbatim to Qt, so on some platforms
you may be able to use any of the following. Most appear on the numeric keypad.
For example, the following may work on some systems:
    
"Ctrl+BackSpace"

Don't use these if you want to be sure that the binding work on all platforms.
The complete list of names may be found at:
http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    
F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab, 
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator, KP_Space, KP_Subtract, KP_Tab,
KP_F1, KP_F2, KP_F3, KP_F4,
KP_0, KP_1, KP_2, KP_3, KP_4, KP_5, KP_6, KP_7, KP_8, KP_9</t>
<t tx="dave.20131104222052.3617"></t>
<t tx="dave.20131104222052.3619"># find
# search/replace
enter-find-search-mode = w
enter-find-replace-and-next-mode -&gt; same = a
enter-find-replace-mode    = s
enter-find-find-next-find-mode -&gt; same = d
enter-find-spell-find-mode -&gt; same = q
enter-find-find-at-cursor-forw-mode -&gt; same = e
# Shift- - reverse/alt
enter-find-search-back-mode  = Shift-w
enter-find-find-next-find-mode -&gt; same = Shift-a
enter-find-replace-all-mode -&gt; same = Shift-s
enter-find-prev-find-mode -&gt; same = Shift-d
enter-find-spell-find-mode -&gt; same = Shift-q
enter-find-find-at-cursor-back-mode -&gt; same = Shift-e


# navigation
enter-find-next-mark-mode -&gt; same = i
enter-find-find-quick-mode -&gt; same = j
enter-find-iter-next-mode -&gt; same = k
enter-find-char-forward-mode -&gt; same = l
# Shift- - reverse
enter-find-next-mark-shift-mode -&gt; same = Shift-i
enter-find-find-quick-selected-mode -&gt; same = Shift-j
enter-find-iter-prev-mode -&gt; same = Shift-k
enter-find-char-backward-mode -&gt; same = Shift-l


</t>
<t tx="dave.20131104222052.3624">enter-text-mode = Ctrl-w
enter-window-mode = Ctrl-a
enter-node-mode = Ctrl-s
enter-find-mode = Ctrl-d</t>
<t tx="dave.20131104222052.3636"># text
# text
enter-text-up-mode -&gt; same = w
enter-text-back-mode -&gt; same = a
enter-text-down-mode -&gt; same = s
enter-text-forward-mode -&gt; same = d
enter-text-beg-line-mode -&gt; same = q
enter-text-end-line-mode -&gt; same = e
# Shift- - extend selection
enter-text-up-extend-selection-mode -&gt; same = Shift-w
enter-text-back-extend-selection-mode -&gt; same = Shift-a
enter-text-down-extend-selection-mode -&gt; same = Shift-s
enter-text-forward-extend-selection-mode -&gt; same = Shift-d
enter-text-beg-line-extend-selection-mode -&gt; same = Shift-q
enter-text-end-line-extend-selection-mode -&gt; same = Shift-e


# block
enter-text-para-prev-mode -&gt; same = i
enter-text-sent-prev-mode -&gt; same = j
enter-text-para-next-mode -&gt; same = k
enter-text-sent-next-mode -&gt; same = l
enter-text-doc-top-mode -&gt; same = u
enter-text-doc-end-mode -&gt; same = o
# Shift- - extend selection
enter-text-para-prev-extend-selection-mode -&gt; same = Shift-i
enter-text-sent-prev-extend-selection-mode -&gt; same = Shift-j
enter-text-para-next-extend-selection-mode -&gt; same = Shift-k
enter-text-sent-next-extend-selection-mode -&gt; same = Shift-l
enter-text-doc-top-extend-selection-mode -&gt; same = Shift-u
enter-text-doc-end-extend-selection-mode -&gt; same = Shift-o


</t>
<t tx="dave.20131104222052.3816">--&gt; previous-line</t>
<t tx="dave.20131104222052.3828">--&gt; back-word-smart</t>
<t tx="dave.20131104222052.3830">--&gt; next-line</t>
<t tx="dave.20131104222052.3832">--&gt; forward-end-word</t>
<t tx="dave.20131104222052.3834">--&gt; beginning-of-line</t>
<t tx="dave.20131104222052.3836">--&gt; end-of-line
</t>
<t tx="dave.20131104222052.3851">--&gt; back-paragraph</t>
<t tx="dave.20131104222052.3853">--&gt; back-sentence</t>
<t tx="dave.20131104222052.3865">--&gt; forward-paragraph</t>
<t tx="dave.20131104222052.3867">--&gt; forward-sentence</t>
<t tx="dave.20131104222052.3869">--&gt; beginning-of-buffer
</t>
<t tx="dave.20131104222052.3871">--&gt; end-of-buffer</t>
<t tx="dave.20131104222052.3874"># window
# focus
enter-window-tree-mode -&gt; same = w
enter-window-editor-mode -&gt; same = a
enter-window-cycle-editor-mode -&gt; same = s
enter-window-cycle-log-mode -&gt; same = d
enter-window-prev-tab-mode -&gt; same = q
enter-window-next-tab-mode -&gt; same = e

# sizing
enter-window-expand-body-mode -&gt; same = i
enter-window-expand-log-mode -&gt; same = j
enter-window-contract-body-mode -&gt; same = k
enter-window-contract-log-mode -&gt; same = l
enter-window-add-editor-mode -&gt; same = u
enter-window-delete-editor-mode -&gt; same = o

</t>
<t tx="dave.20131104222052.3875">--&gt; focus-to-tree</t>
<t tx="dave.20131104222052.3876">--&gt; focus-to-body</t>
<t tx="dave.20131104222052.3877">--&gt; cycle-editor-focus</t>
<t tx="dave.20131104222052.3878">--&gt; focus-to-log
--&gt; cycle-log-focus

# TODO # log focus is off with Alt-x on find tab, also
# may end up using focus-to-nav et al</t>
<t tx="dave.20131104222052.3879">--&gt; tab-cycle-previous</t>
<t tx="dave.20131104222052.3880">--&gt; tab-cycle-next</t>
<t tx="dave.20131104222052.3881">--&gt; expand-body-pane</t>
<t tx="dave.20131104222052.3882">--&gt; contract-log-pane
</t>
<t tx="dave.20131104222052.3883">--&gt; contract-body-pane</t>
<t tx="dave.20131104222052.3884">--&gt; expand-log-pane</t>
<t tx="dave.20131104222052.3885">--&gt; add-editor</t>
<t tx="dave.20131104222052.3886">--&gt; delete-editor</t>
<t tx="dave.20131104222052.3900"># node
# leaf
enter-node-prev-mode -&gt; same = w
enter-node-left-mode -&gt; same = a
enter-node-next-mode -&gt; same = s
enter-node-right-mode -&gt; same = d
enter-node-first-sib-mode -&gt; same = q
enter-node-last-sib-mode -&gt; same = e
# Shift- - move



# branch
enter-node-goto-parent-mode -&gt; same = i
enter-node-history-prev-mode -&gt; same = j
enter-node-toggle-sub-mode -&gt; same = k
enter-node-history-next-mode -&gt; same = l
enter-node-first-mode -&gt; same = u
enter-node-last-mode -&gt; same = o
# Shift- - rename/copypasta



</t>
<t tx="dave.20131104222052.3901">--&gt; goto-prev-visible</t>
<t tx="dave.20131104222052.3902">--&gt; contract-or-go-left</t>
<t tx="dave.20131104222052.3903">--&gt; goto-next-visible</t>
<t tx="dave.20131104222052.3904">--&gt; expand-or-go-right</t>
<t tx="dave.20131104222052.3905">--&gt; goto-first-sibling</t>
<t tx="dave.20131104222052.3906">--&gt; goto-last-sibling</t>
<t tx="dave.20131104222052.3907">--&gt; goto-parent</t>
<t tx="dave.20131104222052.3908">--&gt; goto-prev-history-node</t>
<t tx="dave.20131104222052.3909">--&gt; contract-node</t>
<t tx="dave.20131104222052.3910">--&gt; goto-next-history-node</t>
<t tx="dave.20131104222052.3911">--&gt; goto-first-node</t>
<t tx="dave.20131104222052.3912">--&gt; goto-last-node</t>
<t tx="dave.20131104222052.3913"></t>
<t tx="dave.20131104222052.3914"></t>
<t tx="dave.20131104222052.3915"></t>
<t tx="dave.20131104222052.3916"></t>
<t tx="dave.20131104222052.3917"></t>
<t tx="dave.20131104222052.3918"></t>
<t tx="dave.20131104222052.3919"></t>
<t tx="dave.20131104222052.3920"></t>
<t tx="dave.20131104222052.3921"></t>
<t tx="dave.20131104222052.3922"></t>
<t tx="dave.20131104222052.3925">    </t>
<t tx="dave.20131104222052.3926"></t>
<t tx="dave.20131104222052.3927">--&gt; search-forward</t>
<t tx="dave.20131104222052.3929">--&gt; replace-string</t>
<t tx="dave.20131104222052.3930">--&gt; isearch-forward</t>
<t tx="dave.20131104222052.3932">--&gt; replace-then-find</t>
<t tx="dave.20131104222052.3933">--&gt; goto-next-mark</t>
<t tx="dave.20131104222052.3936">--&gt; find-next</t>
<t tx="dave.20131104222052.3937">--&gt; find-all</t>
<t tx="dave.20131104222052.3938">--&gt; find-character</t>
<t tx="dave.20131104222052.3939">--&gt; find-quick</t>
<t tx="dave.20131104222052.3940"></t>
<t tx="dave.20131104222052.3941"></t>
<t tx="dave.20131104222052.3943">--&gt; find-quick-selected</t>
<t tx="dave.20131104222052.3944">--&gt; do-nothing</t>
<t tx="dave.20131104222052.3950">--&gt; goto-next-mark</t>
<t tx="dave.20131104222052.3952">--&gt; isearch-backward</t>
<t tx="dave.20131104222052.3953">--&gt; backward-find-character</t>
<t tx="dave.20131104222052.3984">--&gt; search-backward</t>
<t tx="dave.20131104222052.3986">--&gt; replace-all</t>
<t tx="dave.20131104222052.3987">--&gt; find-prev</t>
<t tx="dave.20131104222052.3988">--&gt; do-nothing</t>
<t tx="dave.20131104222052.3989">--&gt; do-nothing</t>
<t tx="dave.20131104222052.3996">--&gt; previous-line-extend-selection</t>
<t tx="dave.20131104222052.3997">--&gt; back-word-smart-extend-selection</t>
<t tx="dave.20131104222052.3998">--&gt; next-line-extend-selection</t>
<t tx="dave.20131104222052.3999">--&gt; forward-end-word-extend-selection</t>
<t tx="dave.20131104222052.4000">--&gt; beginning-of-line-extend-selection</t>
<t tx="dave.20131104222052.4001">--&gt; end-of-line-extend-selection
</t>
<t tx="dave.20131104222052.4008">--&gt; back-paragraph-extend-selection</t>
<t tx="dave.20131104222052.4009">--&gt; back-sentence-extend-selection</t>
<t tx="dave.20131104222052.4010">--&gt; forward-paragraph-extend-selection</t>
<t tx="dave.20131104222052.4011">--&gt; forward-sentence-extend-selection</t>
<t tx="dave.20131104222052.4012">--&gt; beginning-of-buffer-extend-selection
</t>
<t tx="dave.20131104222052.4013">--&gt; end-of-buffer-extend-selection</t>
<t tx="dave.20131109134816.5205"># get arg 
u =  c.undoer

def getInput (event=None):
    z = u.beforeChangeNodeContents(p)
    stateName = 'get-input'
    k = c.k
    w = c.frame.body
    y = w.getYScrollPosition()
    state = k.getState(stateName)

    if state == 0:
        k.setLabelBlue('Input: ',protect=True)
        k.getArg(event,stateName,1,getInput)
    else:
        k.clearState()
        
        b,s,e = w.getSelectionLines()
        p.b =  b + '\n'.join([x + k.arg for x in s.split()]) + '\n' + e
    w.setYScrollPosition(y)
    u.afterChangeNodeContents(p,'append-text',z)

getInput()



# this is a comment
# and os is this
# forever we go
</t>
<t tx="dave.20131112150352.3585"># skulls is a basic grammar
# skulls = mode
# mode = controller controller
# controller = mod? actions*
# mod = actions*
# actions = TERM mode?
def actions(poss, buttons, mod=""):
    retval = []
    for pos, button in zip(poss, buttons):
        actName = pos.h.replace("@mode ", "")
        retval.append("enter-" + actName + "-mode -&gt; same = " + mod + button)
    return '\n'.join(retval) + '\n'

def modifier(pos, buttons):
    names = [x.strip() for x in pos.h.split()]
    modName = names[0].lower().capitalize() + "-"
    acts = [x.copy() for x in pos.children()]
    return "# " + modName + " " + " ".join(names[1:]) + '\n' + actions(acts,buttons, mod=modName) + '\n'

def controller(pos, buttons="wasdqe"):
    contName = pos.h.strip().lower()
    # mod?
    mods = []
    acts = [x.copy() for x in pos.children()]
    while not acts[0].h.startswith("@mode "):
        mods.append(modifier(acts[0], buttons))
        acts = acts[1:]
    return "# " + contName + '\n'  + actions(acts,buttons) + '\n'.join(mods) + '\n'
    
def skulls (pos):
    modeName = pos.h.replace("@mode ", "").lower()
    cont = []
    for x in pos.children():
        cont.append(x.copy())
    return "# " + modeName + '\n'+ controller(cont[0]) + controller(cont[1],buttons="ijkluo")
    
    
p.b = skulls(p)</t>
</tnodes>
</leo_file>
